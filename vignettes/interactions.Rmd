---
title: Interacting with InteractionSet classes for genomic interaction data
author: Aaron Lun
date: 16 November 2015 
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{InteractionSet vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r style, echo=FALSE, results="hide", message=FALSE}
require(BiocStyle)
require(knitr)
opts_chunk$set(error=FALSE)
require(InteractionSet)
```

# Introduction

Recently developed techniques such as Hi-C and ChIA-PET have driven the study of genomic interactions, i.e., physical interactions between pairs of genomic regions.
The `r Githubpkg("LTLA/InteractionSet")` package provides classes to represent these interactions, and to store the associated experimental data.
The aim is to provide package developers with stable class definitions that can be manipulated through a large set of methods.
It also provides users with a consistent interface across different packages that use the same classes, making it easier to perform analyses with multiple packages.

Three classes are available from this package:

- `GInteractions`, which represents pairwise interactions between genomic regions.
- `InteractionSet`, which contains experimental data relevant to each interaction.
- `ContactMatrix`, which stores data in a matrix where each row and column represents a genomic region.

This vignette will give a brief description of each class and their associated methods.

# Description of the `GInteractions` class

## Construction

The `GInteractions` class stores any number of pairwise interactions between two genomic regions.
The regions themselves are represented with `GRanges` from the `r Biocpkg("GenomicRanges")` package.
For example, say we have a `GRanges` object containing consecutive intervals that is assigned to `all.regions` (though any regions can be used here):

```{r}
all.regions <- GRanges("chrA", IRanges(0:9*10+1, 1:10*10))
```

Now, let's say we've got a bunch of interactions between elements of `all.regions`.
We'll consider three pairwise interactions -- one between region #1 and #3, another between #5 and #2, and the last between #10 and #6.
Note that the exact order doesn't matter -- here, an interaction between regions A and B is considered to be the same as an interaction between B and A.
Anyway, our set of three interactions can be represented like so:

```{r}
index.1 <- c(1,5,10)
index.2 <- c(3,2,6)
region.1 <- all.regions[index.1]
region.2 <- all.regions[index.2]
```

Construction of a `GInteractions` object can be performed by supplying the interacting regions:

```{r}
gi <- GInteractions(region.1, region.2)
```

This generates a `GInteractions` object of length 3, where each entry corresponds to a pairwise interaction.
Alternatively, the indices can be supplied directly, along with the coordinates of the regions they refer to:

```{r}
gi <- GInteractions(index.1, index.2, all.regions)
gi
```

Note that the `GRanges` are not stored separately for each interaction.
Rather, a common `GRanges` object is used within the `GInteractions` object. 
Each interaction simply provides indices to point at the two relevant intervals representing the interacting regions.
This is because, in many cases, the same intervals are re-used for different interactions. 
Storing indices rather than repeated `GRanges` saves memory in the final representation.

## Getters 

The interacting regions are referred to as anchor regions, because as they "anchor" the ends of the interaction.
These can be accessed, funnily enough, with the `anchors` method:

```{r}
anchors(gi)
```

This returns a `GRangesList` of length 2, where the *i*^th^ interaction is between the *i*^th^ entry of `first` and that of `second`.
We can also obtain `GRanges` for just the first or second anchor regions, by specifying `type="first"` or `"second"`, respectively.
Alternatively, we can get the indices for each interaction directly by setting `id=TRUE`:

```{r}
anchors(gi, id=TRUE)
```

The set of common regions to which those indices point can be obtained with the `regions` method:

```{r}
regions(gi)
```

This is useful for development, as it is often more efficient to manipulate the indices and regions separately.
For example, common operations can be applied to the output of `regions(gi)`, and the relevant results retrieved with the anchor indices.
This is usually faster than applying those operations on repeated instances of the regions in `anchors(gi)`.

A careful reader might notice a couple of things here.
The first is that the `GRanges` returned by `regions` is sorted -- this is automatically performed within the `GInteractions` class, and enforced for consistency.
The second is that the `first` anchor always has a higher genomic start coordinate than the `second` anchor (or, if there are multiple chromosomes, a later-ordered interval).
This is intentional and avoids redundancy from permutations of the anchor regions.

Finally, it's worth pointing out that the `GInteractions` object inherits from the `Vector` base class in the `r Biocpkg("S4Vectors")` package, 
    and subsequently has access to all of its methods.
For example, general metadata can be accessed using the `metadata` method, while interaction-specific metadata can be accessed with the `mcols` method.
For convenience, specific fields in `mcols` can also be accessed directly with the `$` operator.

## Setters 

Modification of the anchors in an existing `GInteractions` object can be performed by supplying new anchor indices.
For example, the code below re-specifies the three pairwise interactions as that between #1 and #5; between #2 and #6; and between #3 and #7, 
    for the corresponding entries in `regions(temp.gi)`.

```{r}
temp.gi <- gi
anchors(temp.gi) <- list(1:3, 5:7)
```

This replacement method probably won't get much use, as it would generally be less confusing to construct a new `GInteractions` object.
Nonetheless, it is provided for purposes of completeness.

Modification of the common regions is probably more useful to most people.
The most typical application would be to annotate regions with some metadata, e.g., whether or not it is a promoter or enhancer:

```{r}
temp.gi <- gi
annotation <- rep(c("E", "P", "N"), length.out=length(all.regions))
regions(temp.gi)$anno <- annotation
```

This will show up when the anchor regions are retrieved:

```{r}
anchors(temp.gi)
```

The existing common regions can be replaced with a superset using the `replaceRegions` method.
This may be useful, e.g., in cases where we want to make the anchor indices point to the correct entries in a larger set of regions.

```{r}
temp.gi <- gi
super.regions <- GRanges("chrA", IRanges(0:19*10+1, 1:20*10))
replaceRegions(temp.gi) <- super.regions
```

Alternatively, any additional regions can be added directly to the common set with the `appendRegions` method.
This is a bit more efficient than calling `replaceRegions` on the concatenation of the extra regions with `regions(temp.gi)`.

```{r}
temp.gi <- gi
extra.regions <- GRanges("chrA", IRanges(10:19*10+1, 11:20*10))
appendRegions(temp.gi) <- extra.regions
```

Finally, the derivation from `Vector` means that we can set some metadata fields as well.
For example, general metadata can be dumped into the `GInteractions` object using the `metadata` method:

```{r}
metadata(gi)$description <- "I am a GInteractions object"
metadata(gi)
```

Interaction-specific metadata can also be stored, via the `mcols` method or through the `$` wrapper.
One application might be to store interesting metrics relevant to each interaction, such as normalized contact frequencies:

```{r}
set.seed(1000)
norm.freq <- rnorm(length(gi)) # obviously, these are not real frequencies.
gi$norm.freq <- norm.freq
mcols(gi)
```

## Subsetting and combining

Subsetting of a `GInteractions` object will return a new object containing only the specified interactions:

```{r}
sub.gi <- gi[1:2]
sub.gi
anchors(sub.gi, id=TRUE)
```

Note that the common regions are *not* modified by subsetting of the `GInteractions` object. 
Subsetting only affects the interactions, i.e., the anchor indices, not the regions to which those indices point.

```{r}
identical(regions(gi), regions(sub.gi))
```

Objects can also be concatenated using `rbind` or `c`. 
This forms a new `GInteractions` object that contains all of the interactions in the constituent objects.
However, it requires that the common regions be the same across all objects.

```{r}
rbind(gi, sub.gi)
```

Objects with different sets of common regions can be concatenated using the `combine` method.
This is more flexible but requires a bit more computational work, hence the distinction from `rbind` and `c`.

```{r}
new.gi <- gi
regions(new.gi) <- resize(regions(new.gi), width=20)
combine(gi, new.gi)
```

## Sorting and duplication

Ordering of `GInteractions` objects is done based on the anchor indices.
Specifically, interactions are ordered such that the first anchor index is increasing.
Any interactions with the same first anchor index are ordered by the second index.

```{r}
new.gi <- gi
anchors(new.gi) <- list(1:3, 5:7)
combined <- c(gi, new.gi)
order(combined)
sorted <- sort(combined)
anchors(sorted, id=TRUE)
```

Recall that the common regions are already sorted within each object.
Sorting of the anchor indices has the additional effect of ensuring that the anchor regions are also sorted by the first (and, if tied, second) anchor coordinates.

```{r}
anchors(sorted, type="first")
```

Duplicated interactions are identified as those that have identical pairs of anchor indices.
In the example below, all of the repeated entries in `doubled` are marked as duplicates.
The `unique` method is also implemented and returns a `GInteractions` object where all duplicated entries bar the first are removed.

```{r}
doubled <- rbind(gi, gi)
duplicated(doubled)
```

## Distance calculations

We are often interested in the distances between interacting regions on the linear genome, to determine if an interaction is local or distal.
These distances can be easily obtained with the `pairdist` function. 
To illustrate, let's construct some more complex interactions -- this time, with multiple chromosomes:

```{r}
all.regions <- GRanges(rep(c("chrA", "chrB"), c(10, 5)), 
        IRanges(c(0:9*10+1, 0:4*5+1), c(1:10*10, 1:5*5)))
index.1 <- c(5, 15,  3, 12, 9, 10)
index.2 <- c(1,  5, 11, 13, 7,  4) 
gi <- GInteractions(index.1, index.2, all.regions)
```

By default, `pairdist` returns the distances between the midpoints of the anchor regions for each interaction.
Any inter-chromosomal interactions will not have a defined distance along the linear genome, so a `NA` is returned instead.

```{r}
pairdist(gi)
```

Different distances can be obtained by specifying the `type` argument, e.g., `"gap"`, `"span"`, `"diagonal"`.
In addition, whether an interaction is intra-chromosomal or not can be determined with the `intrachr` function:

```{r}
intrachr(gi)
```

## Overlap methods

Overlaps can be identified on one dimension, between anchor regions and a linear genomic interval.
Say we want to identify all interactions with at least one anchor region lying within a region of interest (e.g., a known promoter or gene).
This can be done with the `findOverlaps` method, as shown below:
    
```{r}
of.interest <- GRanges("chrA", IRanges(30, 60))
olap <- findOverlaps(gi, of.interest)
olap
```

Examination of the returned `Hits` object reveals that each reported interaction has at least one anchor region overlapping the interval specified in `of.interest`:

```{r}
anchors(gi[queryHits(olap)])
```

Longer `GRanges` can be specified if there are several regions of interest.
Standard arguments can be supplied to `findOverlaps` to modify its behaviour, e.g., `type`, `minoverlap`, `maxgap`, to name a few.
The corresponding `overlapsAny`, `countOverlaps` and `subsetByOverlaps` methods are also available.

A more complex situation involves identifying overlapping interactions in the two-dimensional interaction space.
Say we have an existing interaction betweeen two regions, represented by a `GRangesList` of length 2.
We want to determine if any of our new `GInteractions` interactions overlap with the existing one, e.g., to identify corresponding interactions between data sets.
In particular, we only consider an overlap if each anchor region of the new interaction overlaps a corresponding anchor region of the existing interaction.
To illustrate:

```{r}
paired.interest <- GRangesList(of.interest, GRanges("chrB", IRanges(10, 40)))
olap <- findOverlaps(gi, paired.interest)
olap
```

The existing interaction in `paired.interest` occurs between two intervals, one on chromosome A (i.e., `of.interest`) and another on chromosome B.
Of all the interactions in our `GInteractions` object, only `gi[2]` is considered to be overlapping, 
    despite the fact that multiple interactions in that object overlap with `of.interest` alone.
This is because only `gi[2]` has a concomitant interaction with the interaction partner on chromosome B.

The above call uses a `GRangesList` of length 2, where each constituent `GRanges` has a single interval.
Multiple pairwise interactions can be specified with longer constituent `GRanges`, where corresponding entries between the two `GRanges` represent a single interaction.
Alternatively, two `GInteractions` objects can be overlapped with each other.
Again, arguments can be supplied to `findOverlaps` to tune its behaviour.
The `overlapsAny`, `countOverlaps` and `subsetByOverlaps` methods are also available for these two-dimensional overlaps.

# Description of the `InteractionSet` class

## Construction

The `InteractionSet` class inherits from `SummarizedExperiment0` and holds the experimental data associated with each interaction (along with the interactions themselves).
Each row of an `InteractionSet` object corresponds to one pairwise interaction, while each column corresponds to a sample, e.g., a Hi-C or ChIA-PET library.
A typical use would be to store the count matrix for each interaction in each sample:

```{r}
set.seed(1000)
Nlibs <- 4
counts <- matrix(rpois(Nlibs*length(gi), lambda=10), ncol=Nlibs)
iset <- InteractionSet(counts, gi)
iset
```

Multiple matrices can also be stuffed into the `InteractionSet` object.
For example, if we have a matrix of normalized interaction frequencies, these could be stored along with the raw counts:

```{r}
norm.freq <- matrix(rnorm(Nlibs*length(gi)), ncol=Nlibs)
iset2 <- InteractionSet(list(counts=counts, norm.freq=norm.freq), gi)
iset2
```

Users and developers familiar with the `RangedSummarizedExperiment` class should have little trouble dealing with the `InteractionSet`.
Pairwise interactions and `GInteractions` in the `InteractionSet` class are analogous to genomic intervals and `GRanges` in the `RangedSummarizedExperiment` class.

## Getters

The `InteractionSet` object supports all access methods in the `SummarizedExperiment0` class, e.g., `colData`, `metadata` and so on.
In particular, the `assay` and `assays` method allows extraction of the data matrices:

```{r}
assay(iset)
assay(iset2, 2)
```

The `interactions` method extracts the `GInteractions` object containing the interaction for each row:

```{r}
interactions(iset)
```

Access methods for the `GInteractions` class can also be applied to the `InteractionSet` object.
These are convenience wrappers that will operate on the `GInteractions` object within each `InteractionSet`:

```{r}
anchors(iset, id=TRUE)
regions(iset)
```

## Setters

Again, replacement methods for `SummarizedExperiment0` are supported in the `InteractionSet` class. 
For example, the `colData` holds library-specific information -- one might add library sizes to the `colData` with:

```{r}
lib.size <- seq_len(Nlibs) * 1e6
colData(iset)$lib.size <- lib.size
iset$lib.size <- lib.size # same result.
```

The interactions themselves can be replaced using the `interactions` replacement method:

```{r}
new.gi <- interactions(iset)
new.iset <- iset
regions(new.gi)$score <- 1
interactions(new.iset) <- new.gi
```

Of course, replacement methods for the `GInteractions` class can also be applied here.
These methods will operate directly on the `GInteractions` object within each `InteractionSet`.
This is often more convenient than extracting the interactions, modifying them and then replacing them with `interactions<-`.

```{r}
regions(new.iset)$score <- 1 # same as above.
```

## Subsetting and combining

Subsetting an `InteractionSet` by row will form a new object containing only the specified interactions (and the associated data for all samples), 
    analogous to subsetting of a `GInteractions` object.
However, subsetting the object by column will form a new object containing only the data relevant to the specified *samples*.
This new object will still contain all of the interactions, unless subsetting by row is simultaneously performed.

```{r}
iset[1:3,]
iset[,1:2]
```

`InteractionSet` objects can be combined row-wise using `rbind`, `c` or `combine`, similar to the methods described for `GInteractions`.
This forms a new `InteractionSet` object containing all interactions from each individual object, with the associated data across all samples.
Again, `combine` is distinct from `rbind` or `c` in that objects with different common regions can be combined.
Objects with the same interactions can also be combined column-wise, i.e., to combine data from different samples.
The example below forms an object with an extra copy of the data from sample 3:

```{r}
cbind(iset, iset[,3])
```

## Other methods

Sorting, duplicate detection and overlap methods for `InteractionSet` objects are equivalent to those for `GInteractions`.
Namely, the methods for the former are effectively wrappers that operate on the `GInteractions` method within each `InteractionSet`.
Users should keep in mind that duplicate identification and sorting will not use any experimental data to distinguish between rows that have the same interactions.

# Description of the `ContactMatrix` class

## Construction

The `ContactMatrix` class inherits from the `Annotated` class, and is designed to represent the data in matrix format.
Each row and column of the matrix corresponds to a genomic region, such that each cell of the matrix represents an interaction between the corresponding row and column.
The value of that cell is typically the read pair count for that interaction, but any relevant metric can be used.
Construction is achieved by passing a matrix along with the ranges of the interacting regions for all rows and columns:

```{r}
row.indices <- 1:10
col.indices <- 9:15
row.regions <- all.regions[row.indices]
col.regions <- all.regions[col.indices]
Nr <- length(row.indices)
Nc <- length(col.indices)
counts <- matrix(rpois(Nr*Nc, lambda=10), Nr, Nc)
cm <- ContactMatrix(counts, row.regions, col.regions)
```

For purposes of memory efficiency, the interacting regions for each row or column are internally stored as described for `GInteractions`, 
    i.e., as anchor indices pointing to a set of common regions.
Construction can also be achieved directly from the indices and the set of common regions, as shown below:

```{r}
cm <- ContactMatrix(counts, row.indices, col.indices, all.regions)
cm
```

## Getters

The data matrix can be extracted using the `as.matrix` method:

```{r}
as.matrix(cm)
```

Anchor regions corresponding to each row and column can be extracted with `anchors`.
This is shown below for the row-wise regions.
Indices can also be extracted with `id=TRUE`, as described for the `GInteractions` class.

```{r}
anchors(cm, type="row")
```

The common set of regions can be extracted with `regions`:

```{r}
regions(cm)
```

Inheritance from `Annotated` also means that general metadata can be accessed using the `metadata` method.

## Setters

Parts or all of the data matrix can be modified using the `as.matrix` replacement method:

```{r}
temp.cm <- cm
as.matrix(temp.cm[1,1]) <- 0
```

The `anchors` replacement method can be used to replace the row or column anchor indices:

```{r}
anchors(temp.cm) <- list(1:10, 1:7)
```

The `regions`, `replaceRegions` and `appendRegions` replacement methods are also available and work as described for `GInteractions` objects.
In the example below, the common regions can be updated to include GC content:

```{r}
regions(temp.cm)$GC <- runif(length(regions(temp.cm)))
regions(temp.cm)
```

Finally, the `metadata` replacement method can be used to set metadata:

```{r}
metadata(temp.cm)$description <- "I am a ContactMatrix"
metadata(temp.cm)
```

## Subsetting and combining

Subsetting returns a `ContactMatrix` containing only the specified rows or columns:

```{r}
cm[1:5,]
cm[,1:5]
```

Combining can be done with `rbind` to combine by row, for objects with the same column anchor indices; 
    or with `cbind` to combine by column, for objects with the same row anchor indices.
This forms a new matrix with the additional rows or columns, as one might expect for matrices.

```{r}
rbind(cm, cm[1:5,]) # extra rows
cbind(cm, cm[,1:5]) # extra columns
```

Note that the common regions must be the same in all objects.
If the common regions differ, they should be set to the same value using `replaceRegions` before running `rbind` or `cbind`.
The `combine` method is not provided here, as the generic does not provide methods to determine whether a user would want to combine by row or column.

## Sorting and duplication

Sorting of a `ContactMatrix` involves permuting the rows and columns so that both row and column indices are in ascending order.
This representation is easiest to interpret, as adjacent rows or columns will correspond to adjacent regions.

```{r}
temp.cm <- cm
anchors(temp.cm) <- list(10:1, 15:9)
anchors(sort(temp.cm), id=TRUE)
```

Note that the `order` function does not return an integer vector, as one might expect.
Instead, it returns a list of two integer vectors, containing the permutations for rows and columns respectively:

```{r}
order(temp.cm)
```

Duplicated rows or columns are defined as those with the same index as another row or column, respectively.
The `duplicated` method will return a list of two logical vectors, indicating which rows or columns are considered to be duplicates.
The `unique` method will return a `ContactMatrix` where all duplicates are removed.

```{r}
temp.cm <- rbind(cm, cm)
duplicated(temp.cm)
unique(temp.cm)
```

Users should be aware that the values of the data matrix are *not* considered when identifying duplicates or during sorting.
Only the anchor indices are used for ordering and duplicate detection.

## Overlap methods

The `ContactMatrix` class has access to the `overlapsAny` method for `GRanges` subjects.
This returns a list of two logical vectors indicating whether the row or column anchor regions overlap the interval(s) of interest.

```{r}
of.interest <- GRanges("chrA", IRanges(50, 100))
olap <- overlapsAny(cm, of.interest)
olap
```

Users can use this to subset the `ContactMatrix` according to the overlapping rows and column regions.
Alternatively, we can set up AND or OR masks with these vectors, using the `outer` function:

```{r}
and.mask <- outer(olap$row, olap$column, "&")
or.mask <- outer(olap$row, olap$column, "|")
```

This can be used to mask all uninteresting entries in the data matrix for examination:

```{r}
my.matrix <- as.matrix(cm)
my.matrix[!and.mask] <- NA
my.matrix
```

Two-dimensional overlaps can also be performed by running `overlapsAny` for both interacting regions.
For example, if the first interacting region is `of.interest`, and the second interacting region is as shown below, we can do:

```{r}
olap2 <- overlapsAny(cm, GRanges("chrB", IRanges(1, 20)))
```

This can be used to mask the data, as previously shown:

```{r}
olap.mask <- outer(olap$row, olap2$column, "&") | outer(olap2$row, olap$column, "&")
my.matrix <- as.matrix(cm)
my.matrix[!olap.mask] <- NA
my.matrix
```

# Converting between classes

## Inflating a `GInteractions` into a `ContactMatrix`

If we have a `GInteractions` object, we can convert this into a `ContactMatrix` with specified rows and columns.
Each pairwise interaction corresponds to zero, one or two cells of the `ContactMatrix` (zero if it lies outside of the specified rows and columns, obviously;
    two for some interactions when the `ContactMatrix` is intra-chromosomal and crosses the diagonal of the interaction space).
Each cell is filled with some value associated with the corresponding interaction, e.g., counts, normalized contact frequencies.
Cells with no corresponding interactions in `gi` are set to `NA`.

```{r}
counts <- rpois(length(gi), lambda=10)
desired.rows <- 2:10
desired.cols <- 1:5
new.cm <- inflate(gi, desired.rows, desired.cols, fill=counts)
new.cm
anchors(new.cm, id=TRUE)
as.matrix(new.cm)
```

In the above example, the desired rows and columns are specified by supplying a set of anchor indices.
Alternatively, a `GRanges` object can be passed to the `inflate` method.
The desired rows/columns are defined as those where the corresponding regions overlap any of the intervals in the `GRanges` object.

```{r}
inflate(gi, GRanges("chrA", IRanges(50, 100)), GRanges("chrA", IRanges(10, 50)), fill=counts)
```

Finally, a character vector can be passed to select all rows/columns lying in a set of chromosomes.

```{r}
inflate(gi, "chrA", "chrB", fill=counts)
```

The process is largely the same for converting an `InteractionSet` object into a `ContactMatrix`.
However, some additional arguments are available to extract specific data values from the former for filling of the later.
For example, if we were to fill the `ContactMatrix` using the count data from the 3rd library, we could do:

```{r}
new.cm <- inflate(iset, desired.rows, desired.cols, sample=3)
as.matrix(new.cm)
```

## Deflating a `ContactMatrix` into an `InteractionSet`

The reverse procedure can also be used to convert a `ContactMatrix` into an `InteractionSet`.
This will report pairwise interactions corresponding to each cell of the matrix, with the value of that cell accessible with the `assay` method.

```{r}
new.iset <- deflate(cm)
new.iset
```

Note that duplicated interactions are automatically removed.
This may occur when the `ContactMatrix` crosses the diagonal of the interaction space.
In most cases, duplicate removal is sensible as the values of the matrix should be reflected around the diagonal.
However, if this is not the case, we can preserve duplicates for later processing:

```{r}
deflate(cm, unique=FALSE)
```

## Linearizing an `InteractionSet` into a `RangedSummarizedExperiment`

The `InteractionSet` stores two-dimensional data across the interaction space.
This can be "linearized" into one-dimensional data across the linear genome by only considering the interactions involving a single anchor region.
For example, let's say we're interested in the interactions involving a particular region of chromosome A: 

```{r}
x <- GRanges("chrA", IRanges(42, 48))
rse <- linearize(iset, x)
rse
```

The `linearize` function will identify all interactions involving `x` and return a `RangedSummarizedExperiment` object, 
    where each genomic interval corresponds to the *other* (i.e., non-`x`) region involved in each interaction.
Of course, for self-interactions between `x` and itself, the function just reports `x` in the corresponding interval.

```{r}
rowRanges(rse)
```

This conversion is useful for collapsing 2D data into a 1D form for easier processing.
For example, if counts were being stored in `iset`, then the linearized data in `rse` could be analyzed as if it represented genomic coverage 
    (where the depth of coverage represents the intensity of the interaction of each region in `rowRanges(rse)` with `x`).
One application would be in converting Hi-C data into pseudo-4C data for a user-specified "bait" region.

# Summary

So, there we have it -- three classes to handle interaction data in a variety of forms.
We've covered most of the major features in this vignette, though details for any given method can be found through the standard methods, 
    e.g., `?"anchors,GInteractions"` to get the man page for the `anchors` method.
If you think of some general functionality that might be useful and isn't present here, just let us know and we'll try to stick it in somewhere.

